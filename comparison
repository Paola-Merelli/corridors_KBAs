#######################################################################################################################################
############################################################## TOTAL paths ############################################################

#################### lengths

paths <- vect("prova_ita_iba/prova_corridoi_iba/paths_final/total/paths_Np_nopa.shp")
paths <- st_as_sf(paths)
paths$length_km <- as.numeric(st_length(paths)/ 1000)  
paths_df <- as.data.frame(paths)
summary(paths_df$length_km)
total_lengths <- as.numeric(sum(paths$length_km, na.rm = TRUE))
total_lengths

ggplot(paths_df, aes(y = length_km)) +
  geom_boxplot(fill = "#156082", color = "white") +
  labs(title = "Paths Length - Np/PAs", 
       y = "Length (km)") +
  theme_dark()

st_write(paths, "prova_ita_iba/prova_corridoi_iba/paths_final/paths_Np_nopa.shp")

################## costo
paths <- vect("prova_ita_iba/prova_corridoi_iba/paths_final/paths_Np_nopa.shp")
final_resistance_ita <- rast("prova_ita_iba/produced_layers/final_resistance_ita_nopa.tiff")
np_ita <- vect("prova_ita_iba/produced_layers/np_ita.shp") 

calculate_cost_for_paths <- function(paths, resistance_raster) {
  path_costs <- numeric(nrow(paths))
  for (i in 1:nrow(paths)) {
    resistance_values <- terra::extract(resistance_raster, paths[i, ])
    
    cell_length <- 100  # in meters
    
    # Calculate the total cost for the path as the sum of (resistance * length)
    total_cost <- sum(resistance_values[, 2] * cell_length, na.rm = TRUE)  
    path_costs[i] <- total_cost
  }
  
  # Return vector of costs
  return(path_costs)
}
paths$costs <- calculate_cost_for_paths(paths, final_resistance_ita)
# Calculate the cost per kilometer
cost_per_km <- paths$costs / paths$length_km
paths$cost_per_km <- cost_per_km 
paths_df <- as.data.frame(paths)
summary(paths$cost_per_km)
paths$costs <- paths$costs/ 1e6 # solo per riuscire a salvare tutti i valori, altrimenti alcuni sono troppo grandi 
#writeVector(paths, "prova_ita_iba/prova_corridoi_iba/paths_final/total/paths_Np_nopa.shp")


########################## intersection with PAs
iba_ita <- vect("prova_ita_iba/produced_layers/iba_ita.shp")
#paths <- vect("prova_ita_iba/prova_corridoi_iba/paths_final/total/paths_Np_nopa.shp")
ita_pa <- vect("prova_ita_iba/produced_layers/ita_pa.shp")
ita_pa$ID <- 1:nrow(ita_pa)

###### tot ibas intersected x corridor
intersections_iba <- terra::intersect(paths, iba_ita) %>% as.data.frame()

iba_summary <- intersections_iba %>%
  dplyr::group_by(FID) %>%
  dplyr::summarise(
    num_IBAs = n_distinct(CODICE_IBA),
    IBA_codes = paste(unique(CODICE_IBA), collapse = ", ")
  )
print(iba_summary)

paths <- merge(paths, iba_summary, by.x = "FID", by.y = "FID", all.x = TRUE)
paths_df <- as.data.frame(paths)
summary(paths_df$num_IBAs)


####### tot pas intersected x corridor
intersections_pa <- terra::intersect(paths, ita_pa)
intersections_pa <- as.data.frame(intersections_pa)

pa_summary <- intersections_pa %>%
  dplyr::group_by(FID) %>%
  dplyr::summarise(
    num_PAs = n_distinct(ID))
print(pa_summary)

paths <- merge(paths, pa_summary, by.x = "FID", by.y = "FID", all.x = TRUE)
paths_df <- as.data.frame(paths)
summary(paths_df$num_PAs)

writeVector(paths, "prova_ita_iba/prova_corridoi_iba/paths_final/paths_Np_nopa.shp")

####################################################################################################################################
######################################################## DIRECT path ###############################################################

################### length
paths_union <- vect("prova_ita_iba/prova_corridoi_iba/paths_final/direct/paths_Np_nopa_union.shp") %>% st_as_sf()
paths_union <- st_as_sf(paths_union)
paths_union$lenght_km <- as.numeric(st_length(paths_union) / 1000)  # Lunghezza totale in km
st_write(paths_union, "prova_ita_iba/prova_corridoi_iba/paths_final/paths_Np_nopa_union.shp")

################### costo 

paths_union <- vect("prova_ita_iba/prova_corridoi_iba/paths_final/paths_Np_nopa_union.shp")

calculate_cost_for_paths_direct <- function(path_union, resistance_raster) {
  resistance_values <- terra::extract(resistance_raster, path_union)
  
  cell_length <- 100  
  
  total_cost <- sum(resistance_values[, 2] * cell_length, na.rm = TRUE)  # Exclude NA values
  
  return(total_cost)
}

# Apply the function to the single union path
paths_union$cost <- calculate_cost_for_paths_direct(paths_union, final_resistance_ita)
cost_per_km_union <- paths_union$cost / paths_union$lenght_km
paths_union$cost_per_km <- cost_per_km_union
paths_union_df <- as.data.frame(paths_union)
paths_union$cost <- paths_union$cost / 1e6


######################### intersections with PAs

##### tot iba intersected

intersections_iba_union <- terra::intersect(paths_union, iba_ita) %>% as.data.frame()
paths_union$num_IBAs <- intersections_iba_union %>% distinct(CODICE_IBA) %>% nrow()

######### total pas intersected

intersections_pa_union <- terra::intersect(paths_union, ita_pa) %>% as.data.frame
paths_union$num_PAs <- intersections_pa_union %>% distinct(ID) %>% nrow()
paths_union_df <- as.data.frame(paths_union)

writeVector(paths_union, "prova_ita_iba/prova_corridoi_iba/paths_final/paths_Np_nopa_union.shp")



####################### % land cover classes sul percorso diretto
lc_ita <- vect("prova_ita_iba/U2018_CLC2018_V2020_20u1.shp")
lc_ita_class <- read.csv("prova_ita_iba/CLC_legend.csv")
lc_ita_class <- lc_ita_class %>% rename(Code_18 = CLC_CODE)
lc_ita$Code_18 <- as.character(lc_ita$Code_18)
lc_ita_class$Code_18 <- as.character(lc_ita_class$Code_18)
lc_ita <- merge(lc_ita, lc_ita_class, by = "Code_18", all.x = TRUE)
lc_ita_df <- as.data.frame(lc_ita)

ita <- vect("prova_ita_iba/produced_layers/ita.shp")
r2 <- rast(ext(ita), resolution = c(100, 100))
crs(r2) <- crs(ita) 
raster_lc_ita <- rasterize(lc_ita, r2, field = "CLASS")
lc_intersected <- terra::extract(raster_lc_ita, paths_union)

lc_intersected_df <- as.data.frame(lc_intersected)

# Rimuovi eventuali celle NA (fuori dal raster o senza classe)
lc_intersected_df <- lc_intersected_df[!is.na(lc_intersected_df$CLASS), ]

# Conta il numero totale di celle attraversate
total_cells <- nrow(lc_intersected_df)

# Calcola il numero di celle per ciascuna classe e la percentuale sul totale
class_distribution <- lc_intersected_df %>%
  dplyr::group_by(CLASS) %>%
  dplyr::summarise(count = n()) %>%
  dplyr::mutate(percentage = (count / total_cells) * 100)

# Visualizza il risultato
print(class_distribution)





############### n corridors x ibas sul percorso totale/ridondante
corridors_per_iba <- intersections_iba %>%
  dplyr::group_by(CODICE_IBA) %>%
  dplyr::summarise(num_corridors = n_distinct(FID))

# Aggiungi questa informazione come attributo al vettore `iba_ita`
iba_corr <- merge(iba_ita, corridors_per_iba, by.x = "CODICE_IBA", by.y = "CODICE_IBA", all.x = TRUE)

# Sostituisci eventuali NA in `num_corridors` con 0 per le IBA che non sono intersecate da alcun corridoio
iba_corr$num_corridors[is.na(iba_corr$num_corridors)] <- 0

rli_ita <- read.csv("prova_ita_iba/RLI.csv")

#aggiungo colonna con valori rli
rli_ita <- rli_ita %>% rename(CODICE_IBA = IBA)
iba_corr <- merge(iba_corr, rli_ita[, c("CODICE_IBA", "RLI")], by = "CODICE_IBA", all.x = TRUE)
iba_corr$RLI[is.na(iba_corr$RLI)] <- 1
unique(iba_corr$RLI)
iba_corr_df <- as.data.frame(iba_corr)

write.csv(iba_corr_df, "prova_ita_iba/prova_corridoi_iba/stat/iba_corr_Np_nopa.csv", row.names = FALSE)
plot(iba_corr_df$num_corridors, iba_corr_df$RLI)











######################################################################################################################################
########################################################### PROVE ####################################################################

############## prova ridondanza
redundant_paths_npPAs <- st_intersection(paths_NpPAs)
redundant_length_npPAs <- st_length(st_union(redundant_paths_npPAs)) / 1000
redundant_length_npPAs <- as.numeric(redundant_length_npPAs)
redundant_length_npPAs
percentuale_ridondanza <- (redundant_length_npPAs / paths_NpPAs_union_lenght) * 100
print(percentuale_ridondanza)


################## prova costDistance
### direct
vertices <- terra::crds(paths_NpPAs_union)
total_cost_union <- 0
for (i in 1:(nrow(vertices) - 1)) {
  start <- vertices[i, ]
  end <- vertices[i + 1, ]

  cost_segment <- costDistance(trans_corr, start, end)
  total_cost_union <- total_cost_union + as.numeric(cost_segment)
}

### tot
#np_ita <- vect("prova_ita_iba/produced_layers/np_ita.shp")
#ita <- vect("prova_ita_iba/produced_layers/ita.shp")
#ita_raster <- rast("prova_ita_iba/produced_layers/ita_rast.tiff")
final_resistance_ita_NpPAs <- rast("prova_ita_iba/produced_layers/final_resistance_ita.tiff")
centroidi_ita <- centroids(np_ita, inside=FALSE)

resistance_resampled <- aggregate(final_resistance_ita_NpPAs, fact = 2, fun = mean)
conductance_raster <- 1 / resistance_resampled
conductance_raster_RL <- raster(conductance_raster)

conductance_raster_RL[is.na(conductance_raster_RL)] <- 1e-10
conductance_raster_RL[!is.finite(conductance_raster_RL)] <- 1e10

#transition layer
trans <- transition(conductance_raster_RL, transitionFunction = mean, directions = 8)

trans_corr <- geoCorrection(trans)

#function
calcolaCosto <- function(start, end) {
  costo <- costDistance(trans_corr, start, end)
  return(as.numeric(costo))
}


centroid_indices <- 1:nrow(centroidi_ita)
pairs <- combn(centroid_indices, 2)
costi_cumulativi <- numeric(ncol(pairs))
# Itera su tutte le coppie di centroidi
for (k in 1:ncol(pairs)) {
  i <- pairs[1, k]
  j <- pairs[2, k]
  
  start <- terra::crds(centroidi_ita)[i, , drop = F ]
  end <- terra::crds(centroidi_ita)[j, , drop = F ]
  
  costi_cumulativi[k] <- calcolaCosto(start, end)
}

print(costi_cumulativi)

costi_cumulativi_NpPAs <- as.data.frame(costi_cumulativi)
costi_cumulativi_NpPAs <- log10(costi_cumulativi_NpPAs)
head(costi_cumulativi_NpPAs)
summary(costi_cumulativi_NpPAs)
